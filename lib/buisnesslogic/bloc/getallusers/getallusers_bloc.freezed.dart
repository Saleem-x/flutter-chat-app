// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'getallusers_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GetallusersEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getallusers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getallusers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getallusers,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Getallusersvent value) getallusers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Getallusersvent value)? getallusers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Getallusersvent value)? getallusers,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetallusersEventCopyWith<$Res> {
  factory $GetallusersEventCopyWith(
          GetallusersEvent value, $Res Function(GetallusersEvent) then) =
      _$GetallusersEventCopyWithImpl<$Res, GetallusersEvent>;
}

/// @nodoc
class _$GetallusersEventCopyWithImpl<$Res, $Val extends GetallusersEvent>
    implements $GetallusersEventCopyWith<$Res> {
  _$GetallusersEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetallusersventCopyWith<$Res> {
  factory _$$GetallusersventCopyWith(
          _$Getallusersvent value, $Res Function(_$Getallusersvent) then) =
      __$$GetallusersventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetallusersventCopyWithImpl<$Res>
    extends _$GetallusersEventCopyWithImpl<$Res, _$Getallusersvent>
    implements _$$GetallusersventCopyWith<$Res> {
  __$$GetallusersventCopyWithImpl(
      _$Getallusersvent _value, $Res Function(_$Getallusersvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Getallusersvent implements Getallusersvent {
  const _$Getallusersvent();

  @override
  String toString() {
    return 'GetallusersEvent.getallusers()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Getallusersvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getallusers,
  }) {
    return getallusers();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getallusers,
  }) {
    return getallusers?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getallusers,
    required TResult orElse(),
  }) {
    if (getallusers != null) {
      return getallusers();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Getallusersvent value) getallusers,
  }) {
    return getallusers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Getallusersvent value)? getallusers,
  }) {
    return getallusers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Getallusersvent value)? getallusers,
    required TResult orElse(),
  }) {
    if (getallusers != null) {
      return getallusers(this);
    }
    return orElse();
  }
}

abstract class Getallusersvent implements GetallusersEvent {
  const factory Getallusersvent() = _$Getallusersvent;
}

/// @nodoc
mixin _$GetallusersState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist) $default, {
    required TResult Function() errorstate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<AccountInfo>? alluserslist)? $default, {
    TResult? Function()? errorstate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist)? $default, {
    TResult Function()? errorstate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GetallusersState value) $default, {
    required TResult Function(_errorstate value) errorstate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_GetallusersState value)? $default, {
    TResult? Function(_errorstate value)? errorstate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GetallusersState value)? $default, {
    TResult Function(_errorstate value)? errorstate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetallusersStateCopyWith<$Res> {
  factory $GetallusersStateCopyWith(
          GetallusersState value, $Res Function(GetallusersState) then) =
      _$GetallusersStateCopyWithImpl<$Res, GetallusersState>;
}

/// @nodoc
class _$GetallusersStateCopyWithImpl<$Res, $Val extends GetallusersState>
    implements $GetallusersStateCopyWith<$Res> {
  _$GetallusersStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_GetallusersStateCopyWith<$Res> {
  factory _$$_GetallusersStateCopyWith(
          _$_GetallusersState value, $Res Function(_$_GetallusersState) then) =
      __$$_GetallusersStateCopyWithImpl<$Res>;
  @useResult
  $Res call({List<AccountInfo>? alluserslist});
}

/// @nodoc
class __$$_GetallusersStateCopyWithImpl<$Res>
    extends _$GetallusersStateCopyWithImpl<$Res, _$_GetallusersState>
    implements _$$_GetallusersStateCopyWith<$Res> {
  __$$_GetallusersStateCopyWithImpl(
      _$_GetallusersState _value, $Res Function(_$_GetallusersState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? alluserslist = freezed,
  }) {
    return _then(_$_GetallusersState(
      alluserslist: freezed == alluserslist
          ? _value._alluserslist
          : alluserslist // ignore: cast_nullable_to_non_nullable
              as List<AccountInfo>?,
    ));
  }
}

/// @nodoc

class _$_GetallusersState implements _GetallusersState {
  const _$_GetallusersState({required final List<AccountInfo>? alluserslist})
      : _alluserslist = alluserslist;

  final List<AccountInfo>? _alluserslist;
  @override
  List<AccountInfo>? get alluserslist {
    final value = _alluserslist;
    if (value == null) return null;
    if (_alluserslist is EqualUnmodifiableListView) return _alluserslist;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'GetallusersState(alluserslist: $alluserslist)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GetallusersState &&
            const DeepCollectionEquality()
                .equals(other._alluserslist, _alluserslist));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_alluserslist));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GetallusersStateCopyWith<_$_GetallusersState> get copyWith =>
      __$$_GetallusersStateCopyWithImpl<_$_GetallusersState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist) $default, {
    required TResult Function() errorstate,
  }) {
    return $default(alluserslist);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<AccountInfo>? alluserslist)? $default, {
    TResult? Function()? errorstate,
  }) {
    return $default?.call(alluserslist);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist)? $default, {
    TResult Function()? errorstate,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(alluserslist);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GetallusersState value) $default, {
    required TResult Function(_errorstate value) errorstate,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_GetallusersState value)? $default, {
    TResult? Function(_errorstate value)? errorstate,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GetallusersState value)? $default, {
    TResult Function(_errorstate value)? errorstate,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _GetallusersState implements GetallusersState {
  const factory _GetallusersState(
      {required final List<AccountInfo>? alluserslist}) = _$_GetallusersState;

  List<AccountInfo>? get alluserslist;
  @JsonKey(ignore: true)
  _$$_GetallusersStateCopyWith<_$_GetallusersState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_errorstateCopyWith<$Res> {
  factory _$$_errorstateCopyWith(
          _$_errorstate value, $Res Function(_$_errorstate) then) =
      __$$_errorstateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_errorstateCopyWithImpl<$Res>
    extends _$GetallusersStateCopyWithImpl<$Res, _$_errorstate>
    implements _$$_errorstateCopyWith<$Res> {
  __$$_errorstateCopyWithImpl(
      _$_errorstate _value, $Res Function(_$_errorstate) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_errorstate implements _errorstate {
  const _$_errorstate();

  @override
  String toString() {
    return 'GetallusersState.errorstate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_errorstate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist) $default, {
    required TResult Function() errorstate,
  }) {
    return errorstate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(List<AccountInfo>? alluserslist)? $default, {
    TResult? Function()? errorstate,
  }) {
    return errorstate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(List<AccountInfo>? alluserslist)? $default, {
    TResult Function()? errorstate,
    required TResult orElse(),
  }) {
    if (errorstate != null) {
      return errorstate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_GetallusersState value) $default, {
    required TResult Function(_errorstate value) errorstate,
  }) {
    return errorstate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_GetallusersState value)? $default, {
    TResult? Function(_errorstate value)? errorstate,
  }) {
    return errorstate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_GetallusersState value)? $default, {
    TResult Function(_errorstate value)? errorstate,
    required TResult orElse(),
  }) {
    if (errorstate != null) {
      return errorstate(this);
    }
    return orElse();
  }
}

abstract class _errorstate implements GetallusersState {
  const factory _errorstate() = _$_errorstate;
}
